##Design Decisions
- I built my game from the Tic-Tac-Toe sample because it was set up for two players. When I noticed the extended endpoints already added to Tic-Tac-Toe, I deleted them, so I could build them myself.
- User model: added win_rate to simplify user_ranking queries. 
- Game model - Inherited from Tic-Tac-Toe: KeyProperties for players (player_one, player_two), active (boolean to indicate player whose turn it is), game_over (boolean to indicate no more moves allowed), and history (list of tuples, stored in PickleProperty).
- Game play - Added cards: FULL_DECK (a list of strings defined in constants.py), with text representation of cards (suit-value), and a function to deal cards from deck in Game model. 
- Game model - Added attributes: deck (PickleProperty preserving list-of-strings representation of cards remaining in deck after each deal); both players’ hands (hand_one, hand_two) and draw_card also stored with PickleProperty for easy manipulation of lists; instructions (to prompt user input); mid_move (boolean to indicate mid-move state).
- Game play: Player's turn takes two moves. In start_move, active player inputs “1” to take the draw_card (most recently discarded card, visible) or “2” to draw from the deck. Selected card is added to active player's hand. In end_move, active player inputs discard from his/her hand. Discard is removed and becomes draw_card for other player, who becomes active player when end_move is complete.
- GameForm and HandForm intentionally separated so players can see state of the game (including active player) without peeking at opponent’s cards.
- The most fun (and challenging) part of designing this game was writing the code to verify a winning player's hand. First, the hand is transformed from human-readable to python-readable form. Then each suit is tested for runs of at least 3 cards in a row. Long runs (4+ cards) are stored to help with short sets later. Leftover cards (that didn't fit into a run) are checked for 3+ card sets (multiple cards of the same number). A set of 1 or 2 cards could be completed by adding the missing multiples from the beginning or end of a “long run.”
- Score model: added penalty_winner and penalty_loser (each player’s “deadwood” points when game ended). This supports a score “leaderboard” (get_high_scores) which ranks scores by lowest penalty_winner. Because it’s possible to win and still have a penalty score (if opponent’s “out”-attempt failed or deck ran out of cards), this ranking still makes sense.
- Score entity is reserved for completed game data (including winner, loser and penalties), while Game entity records data for game-in-progress, including history. I don't want to duplicate score-entity data in game-entity, but it would also be nice to see history AND results of a game in a single form. Not sure if it's possible to populate a single form drawing from two models.
- Cronjob alerts players about games-in-progress every 24 hours, and the push queue sends an e-mail to a player right after their opponent finishes end_move.
